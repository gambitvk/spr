from abc import ABC, abstractmethod
import random
from typing import List, Callable


class Player(ABC):
    """
    A abstract class to represent player of a game

    Attributes:
        name: str
            name of the player

    Methods:
        get_choice() -> str (abstract)
            return gesture choice of a player
        from_kwargs(**kwargs) -> cls
            returns the child object created from kwargs

    """

    def __init__(self, name: str, gestures: List[str]) -> None:
        """
        Construct a base player class

        Parms:
            name: str
                name of player
            gestures: List[str]
                list of all gestures's names
        """

        self._name = name
        self._gestures = gestures
        super().__init__()

    @property
    def name(self) -> None:
        """
        Player's name
        """
        return self._name

    @abstractmethod
    def get_choice(self) -> str:
        """
        Return gesture choice of the player. To be implemented by inherited
        class

        Returns:
            gesture: str
                name of gesture
        """

        raise NotImplementedError

    @classmethod
    def from_kwargs(cls, **kwargs):
        """
        Create an object that inherits from Player base on kwargs
        """

        name = kwargs.get('name')
        if name is None:
            raise ValueError("missing name from player creation")

        gestures = kwargs.get('gestures')
        if gestures is None:
            raise ValueError("missing gestures from player creation")

        return cls(name, gestures)


class Human(Player):
    """
    A class represent a Human player

    Attributes:
        name: str
            name of Human

    Methods:
        from_kwargs(**kwargs) -> Human
            create a Human object base on kwargs
        get_choice()  -> str
            prompt user for gesture choice and return the name of gesture
    """

    def __init__(self, name: str, gestures: List[str],
                 get_user_choice_fn: Callable[[str, dict], str]) -> None:
        """
        Construct a Human object

        Params:
            name: str
                name of Human
            gestures: List[str]
                list of gestures names
            get_user_choice_fn: [[str, dict], str]
                function object that  prompt user to make a choice and return
                it.

                Parms:
                    str - Name of player
                    dict - enumerated dictionary of index and gestures

                Returns:
                    str - index as string
        """

        super().__init__(name, gestures)
        self._ges_dict = {index: elem for index, elem in enumerate(gestures)}
        self._get_user_choice_fn = get_user_choice_fn

    @classmethod
    def from_kwargs(cls, **kwargs):
        """
        Creates a Human from kwargs

        Params:
            kwargs -
                name - Human name
                gestures - list of gestures names
                get_user_choice_fn - function to prompt user for chocie
        """

        name = kwargs.get('name')
        if name is None:
            raise ValueError("missing name from player creation")

        gestures = kwargs.get('gestures')
        if gestures is None:
            raise ValueError("missing gestures from player creation")

        get_user_choice_fn = kwargs.get('get_user_choice_fn')
        if get_user_choice_fn is None:
            raise ValueError("missing get_user_choice_fn from player creation")

        return cls(name, gestures, get_user_choice_fn)

    def get_choice(self) -> str:
        """
        Returns use's choices, keep prompting if user input is invalid
        """

        while(1):
            input_str = self._get_user_choice_fn(self._name, self._ges_dict)
            index = None
            try:
                index = int(input_str)
                if index < 0 or index >= len(self._ges_dict):
                    raise ValueError("Selection not in range")
                return self._ges_dict[index]
            except ValueError:
                print(f"Invalid selection\n")


class Computer(Player):
    """
    A class represent a Computer player

    Methods:
        get_choice() -> str
            returns a gesture choice generated by computer
    """

    def get_choice(self) -> str:
        """
        Returns a gesture choice generated by computer
        """

        return random.choice(self._gestures)


class PlayerCreator():
    """
    A class to help makes list of players base on json config

    Methods:
        create(config: dict, **kwargs) -> list
            create a list of players
    """

    _creators = {'Human': Human, 'Computer': Computer}

    @classmethod
    def _create(cls, player, **kwargs):
        key = player['type']
        creator = cls._creators.get(key)
        if not creator:
            raise ValueError(f"Unknown Player type {key}")

        return creator.from_kwargs(name=player['name'], **kwargs)

    @staticmethod
    def _validate_players(players: List[dict]) -> None:
        if (not players or len(players) < 2):
            raise ValueError('Must define at least 2 players in config')

        names = [x.get('name') for x in players]
        if len(names) != len(set(names)):
            raise ValueError('Players name needs to be unique. Check config!')

    @classmethod
    def create(cls, config: dict, **kwargs) -> list:
        """
        Returns a list of players(inherits from Player)

        Params:
            config: dict
                players configurations from a json file

                sample:
                    {
                        "players": [
                            {'name': 'human 1', 'type','Human'},
                            {'name': 'com 1', 'type','Computer'},
                        ]
                    }
            kwargs: dict
                other parameters required by different Players

        Returns:
            List[Human,Computer....]
        """

        players = config.get('players')
        cls._validate_players(players)
        try:
            return [cls._create(player, **kwargs) for player in players]
        except Exception as e:
            raise ValueError(f"Malformed config file error: {e}")
